Joe Jevnik

source:
  dslab.ee.ncku.edu.tw/~tmc/final.pptâ€Ž

Background:
The function mmap() is used to map process address space memory addresses to
memory objects; commonly these objects are files. When mapping to a file, one
must consider what a file is in memory. In Unix-styled file systems, a file is
a pointer to an inode (index node). The inode is a structure that contains a
section with the status of the file, commonly accessed through the `stat`
command, or through the system call stat(), and then pointers to blocks that
hold the file's data.
[INSERT INODE DIAGRAM NEAR HERE]
The blocks are fixed size, and thus all data stored in any file will occupy some
number of blocks. A file n bytes wide, with a block size of b will then occupy:
(n div b) + 1 blocks. With this information, we may try to use this block style
IO to hide information.

Method:
The method used to hide information results from the fact that although the
physical space allocated for a file is a multiple of the block size, the file
may contain any non-negative size up to the limit of the file system. For
example, a file that contains only the single character 'a' will be 1 byte wide
(0x61); however, when the file is saved, it will occupy an entire block. The
concept is to write data into this extra space that is allocated for the file,
but otherwise unused.

Implementation:
When one creates a new file, it has no blocks associated with it. As soon as
you try to write data to it, it must allocate a block. We start by writing any
non-null string to the file we wish to hide information in. This forces our file
to aquire some space. We may calculate exactly how much space we have left to
work with using the following function f: Z -> Z

    let b = The block size, n = The number of bytes that will be visible.
    f n | 0,             if n is an element of Z_b
        | b - (n mod b), otherwise

This is because if one writes a multiple of the page size of bytes, it will not
allocate a new page resulting in 0 free space, and otherwise, we will only have
the amount of unused space in the last page.
[SECOND INODE DIAGRAM]
Therefore, we start by writing the visible bytes to the file. Afterwards, we
must map this file to memory using mmap(). This now gives us an pointer that
points to this file. To write the hidden data, we must only write to the
locations: pointer + m, for m >= n and (locations + m) mod b > 0. If we attempt
to write to locations where 0 <= m < n, we will be overwriting the visible data,
and if we break the bounds in the other direction, we will experience undefined
behavior, most likely a SIGBUS error, as we will be addressing random memory
that is not associated with our file.

To read this hidden data, one must preform a very simmilar task. Simply load
the file into memory with mmap() and begin reading that array from indecies that
are after the length of the file.

Notes about implementation:
When testing, I was running linux 3.14-rc4 through linux 3.14-rc6, tested on
ext4 and ntfs journaling systems with a page size of 4096.

Limitations:
One major limitation is that it is difficult to distribute this hidden data. The
internet does not work with block IO. When I upload a file 1 byte wide, it would
only upload that byte's data, not the whole page. Complementary, when
downloading one byte of data, I would only reviece that byte, not the page it is
stored in on the server. This makes transfer via the internet impossible with
common transfer means. Another difficulty is that file copying is not normally
done with blocks either. Using the standard GNU cp program to copy these files
will result in a loss of the hidden data, as it will be equivelent to allocating
the same amount of blocks, and then memcpy'ing the blocks up the length of the
file. This means the only way to make a local copy is with a special copy
program that would once again call mmap() and re-write the data that was there.
This does not affect hard links though, as hard links all point to the same
inode, so they will be sharing the same blocks. This is a limitation and an
advantage in the sense that it makes it very difficult for someone to copy this
hidden data unknowingly and distribute it, or to steal it. One means that could
be used is to copy onto some external physical storage device, such as a USB
mass storage device using the special copy program, and then using that same
program to move it off the device onto another machine. A big limitation is the
amount of data that can be hidden in a single file. Because the data is so
limited, one alternative would be to write the location of a place to find a
larger message, such as a URL. Corolary, hiding a compiled binary may be
difficult, but one may hide an interpreted program there. For example, one could
hide a bash script that curl'ed a binary, called chmod +x, and then executed it.
This allows for smaller amounts of data to result in more actions. I was able to
fit a hello world into the hidden section, but not much else, as full elf64's
are commonly larger than 4095 bytes.